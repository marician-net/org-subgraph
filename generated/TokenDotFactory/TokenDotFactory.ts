// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class DotTokenCreated extends ethereum.Event {
  get params(): DotTokenCreated__Params {
    return new DotTokenCreated__Params(this);
  }
}

export class DotTokenCreated__Params {
  _event: DotTokenCreated;

  constructor(event: DotTokenCreated) {
    this._event = event;
  }

  get tokenAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class TokenDotFactory extends ethereum.SmartContract {
  static bind(address: Address): TokenDotFactory {
    return new TokenDotFactory("TokenDotFactory", address);
  }

  initializeCurve(
    specifier: Bytes,
    symbol: Bytes,
    curve: Array<BigInt>
  ): Address {
    let result = super.call(
      "initializeCurve",
      "initializeCurve(bytes32,bytes32,int256[]):(address)",
      [
        ethereum.Value.fromFixedBytes(specifier),
        ethereum.Value.fromFixedBytes(symbol),
        ethereum.Value.fromSignedBigIntArray(curve)
      ]
    );

    return result[0].toAddress();
  }

  try_initializeCurve(
    specifier: Bytes,
    symbol: Bytes,
    curve: Array<BigInt>
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "initializeCurve",
      "initializeCurve(bytes32,bytes32,int256[]):(address)",
      [
        ethereum.Value.fromFixedBytes(specifier),
        ethereum.Value.fromFixedBytes(symbol),
        ethereum.Value.fromSignedBigIntArray(curve)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  newToken(name: string, symbol: string): Address {
    let result = super.call("newToken", "newToken(string,string):(address)", [
      ethereum.Value.fromString(name),
      ethereum.Value.fromString(symbol)
    ]);

    return result[0].toAddress();
  }

  try_newToken(name: string, symbol: string): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "newToken",
      "newToken(string,string):(address)",
      [ethereum.Value.fromString(name), ethereum.Value.fromString(symbol)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  toBytes(x: Address): Bytes {
    let result = super.call("toBytes", "toBytes(address):(bytes)", [
      ethereum.Value.fromAddress(x)
    ]);

    return result[0].toBytes();
  }

  try_toBytes(x: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall("toBytes", "toBytes(address):(bytes)", [
      ethereum.Value.fromAddress(x)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  bytesToAddr(b: Bytes): Address {
    let result = super.call("bytesToAddr", "bytesToAddr(bytes):(address)", [
      ethereum.Value.fromBytes(b)
    ]);

    return result[0].toAddress();
  }

  try_bytesToAddr(b: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("bytesToAddr", "bytesToAddr(bytes):(address)", [
      ethereum.Value.fromBytes(b)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  curves(param0: Bytes): Address {
    let result = super.call("curves", "curves(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toAddress();
  }

  try_curves(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("curves", "curves(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  bytes32ToString(x: Bytes): string {
    let result = super.call(
      "bytes32ToString",
      "bytes32ToString(bytes32):(string)",
      [ethereum.Value.fromFixedBytes(x)]
    );

    return result[0].toString();
  }

  try_bytes32ToString(x: Bytes): ethereum.CallResult<string> {
    let result = super.tryCall(
      "bytes32ToString",
      "bytes32ToString(bytes32):(string)",
      [ethereum.Value.fromFixedBytes(x)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  coord(): Address {
    let result = super.call("coord", "coord():(address)", []);

    return result[0].toAddress();
  }

  try_coord(): ethereum.CallResult<Address> {
    let result = super.tryCall("coord", "coord():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getTokenAddress(specifier: Bytes): Address {
    let result = super.call(
      "getTokenAddress",
      "getTokenAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(specifier)]
    );

    return result[0].toAddress();
  }

  try_getTokenAddress(specifier: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getTokenAddress",
      "getTokenAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(specifier)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenFactory(): Address {
    let result = super.call("tokenFactory", "tokenFactory():(address)", []);

    return result[0].toAddress();
  }

  try_tokenFactory(): ethereum.CallResult<Address> {
    let result = super.tryCall("tokenFactory", "tokenFactory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reserveToken(): Address {
    let result = super.call("reserveToken", "reserveToken():(address)", []);

    return result[0].toAddress();
  }

  try_reserveToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("reserveToken", "reserveToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class InitializeCurveCall extends ethereum.Call {
  get inputs(): InitializeCurveCall__Inputs {
    return new InitializeCurveCall__Inputs(this);
  }

  get outputs(): InitializeCurveCall__Outputs {
    return new InitializeCurveCall__Outputs(this);
  }
}

export class InitializeCurveCall__Inputs {
  _call: InitializeCurveCall;

  constructor(call: InitializeCurveCall) {
    this._call = call;
  }

  get specifier(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get symbol(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get curve(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }
}

export class InitializeCurveCall__Outputs {
  _call: InitializeCurveCall;

  constructor(call: InitializeCurveCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class NewTokenCall extends ethereum.Call {
  get inputs(): NewTokenCall__Inputs {
    return new NewTokenCall__Inputs(this);
  }

  get outputs(): NewTokenCall__Outputs {
    return new NewTokenCall__Outputs(this);
  }
}

export class NewTokenCall__Inputs {
  _call: NewTokenCall;

  constructor(call: NewTokenCall) {
    this._call = call;
  }

  get name(): string {
    return this._call.inputValues[0].value.toString();
  }

  get symbol(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class NewTokenCall__Outputs {
  _call: NewTokenCall;

  constructor(call: NewTokenCall) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class UnbondCall extends ethereum.Call {
  get inputs(): UnbondCall__Inputs {
    return new UnbondCall__Inputs(this);
  }

  get outputs(): UnbondCall__Outputs {
    return new UnbondCall__Outputs(this);
  }
}

export class UnbondCall__Inputs {
  _call: UnbondCall;

  constructor(call: UnbondCall) {
    this._call = call;
  }

  get specifier(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UnbondCall__Outputs {
  _call: UnbondCall;

  constructor(call: UnbondCall) {
    this._call = call;
  }
}

export class BondCall extends ethereum.Call {
  get inputs(): BondCall__Inputs {
    return new BondCall__Inputs(this);
  }

  get outputs(): BondCall__Outputs {
    return new BondCall__Outputs(this);
  }
}

export class BondCall__Inputs {
  _call: BondCall;

  constructor(call: BondCall) {
    this._call = call;
  }

  get specifier(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class BondCall__Outputs {
  _call: BondCall;

  constructor(call: BondCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get coordinator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get factory(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get providerPubKey(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get providerTitle(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
