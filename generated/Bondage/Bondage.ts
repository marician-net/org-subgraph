// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Bound extends ethereum.Event {
  get params(): Bound__Params {
    return new Bound__Params(this);
  }
}

export class Bound__Params {
  _event: Bound;

  constructor(event: Bound) {
    this._event = event;
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oracle(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get numZap(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get numDots(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Unbound extends ethereum.Event {
  get params(): Unbound__Params {
    return new Unbound__Params(this);
  }
}

export class Unbound__Params {
  _event: Unbound;

  constructor(event: Unbound) {
    this._event = event;
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oracle(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Escrowed extends ethereum.Event {
  get params(): Escrowed__Params {
    return new Escrowed__Params(this);
  }
}

export class Escrowed__Params {
  _event: Escrowed;

  constructor(event: Escrowed) {
    this._event = event;
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oracle(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Released extends ethereum.Event {
  get params(): Released__Params {
    return new Released__Params(this);
  }
}

export class Released__Params {
  _event: Released;

  constructor(event: Released) {
    this._event = event;
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oracle(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Returned extends ethereum.Event {
  get params(): Returned__Params {
    return new Returned__Params(this);
  }
}

export class Returned__Params {
  _event: Returned;

  constructor(event: Returned) {
    this._event = event;
  }

  get holder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get oracle(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Bondage extends ethereum.SmartContract {
  static bind(address: Address): Bondage {
    return new Bondage("Bondage", address);
  }

  isProviderInitialized(
    holderAddress: Address,
    oracleAddress: Address
  ): boolean {
    let result = super.call(
      "isProviderInitialized",
      "isProviderInitialized(address,address):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress)
      ]
    );

    return result[0].toBoolean();
  }

  try_isProviderInitialized(
    holderAddress: Address,
    oracleAddress: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isProviderInitialized",
      "isProviderInitialized(address,address):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  escrowDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): boolean {
    let result = super.call(
      "escrowDots",
      "escrowDots(address,address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );

    return result[0].toBoolean();
  }

  try_escrowDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "escrowDots",
      "escrowDots(address,address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getZapBound(oracleAddress: Address, endpoint: Bytes): BigInt {
    let result = super.call(
      "getZapBound",
      "getZapBound(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );

    return result[0].toBigInt();
  }

  try_getZapBound(
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getZapBound",
      "getZapBound(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getDotsIssued(oracleAddress: Address, endpoint: Bytes): BigInt {
    let result = super.call(
      "getDotsIssued",
      "getDotsIssued(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );

    return result[0].toBigInt();
  }

  try_getDotsIssued(
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getDotsIssued",
      "getDotsIssued(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  dotLimit(oracleAddress: Address, endpoint: Bytes): BigInt {
    let result = super.call("dotLimit", "dotLimit(address,bytes32):(uint256)", [
      ethereum.Value.fromAddress(oracleAddress),
      ethereum.Value.fromFixedBytes(endpoint)
    ]);

    return result[0].toBigInt();
  }

  try_dotLimit(
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "dotLimit",
      "dotLimit(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  releaseDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): boolean {
    let result = super.call(
      "releaseDots",
      "releaseDots(address,address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );

    return result[0].toBoolean();
  }

  try_releaseDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "releaseDots",
      "releaseDots(address,address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getNumZap(oracleAddress: Address, endpoint: Bytes): BigInt {
    let result = super.call(
      "getNumZap",
      "getNumZap(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );

    return result[0].toBigInt();
  }

  try_getNumZap(
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNumZap",
      "getNumZap(address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  db(): Address {
    let result = super.call("db", "db():(address)", []);

    return result[0].toAddress();
  }

  try_db(): ethereum.CallResult<Address> {
    let result = super.tryCall("db", "db():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  arbiterAddress(): Address {
    let result = super.call("arbiterAddress", "arbiterAddress():(address)", []);

    return result[0].toAddress();
  }

  try_arbiterAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "arbiterAddress",
      "arbiterAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getNumEscrow(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes
  ): BigInt {
    let result = super.call(
      "getNumEscrow",
      "getNumEscrow(address,address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );

    return result[0].toBigInt();
  }

  try_getNumEscrow(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNumEscrow",
      "getNumEscrow(address,address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getOracleAddress(holderAddress: Address, index: BigInt): Address {
    let result = super.call(
      "getOracleAddress",
      "getOracleAddress(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromUnsignedBigInt(index)
      ]
    );

    return result[0].toAddress();
  }

  try_getOracleAddress(
    holderAddress: Address,
    index: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getOracleAddress",
      "getOracleAddress(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromUnsignedBigInt(index)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  bond(oracleAddress: Address, endpoint: Bytes, numDots: BigInt): BigInt {
    let result = super.call("bond", "bond(address,bytes32,uint256):(uint256)", [
      ethereum.Value.fromAddress(oracleAddress),
      ethereum.Value.fromFixedBytes(endpoint),
      ethereum.Value.fromUnsignedBigInt(numDots)
    ]);

    return result[0].toBigInt();
  }

  try_bond(
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "bond",
      "bond(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getEndpointBroker(oracleAddress: Address, endpoint: Bytes): Address {
    let result = super.call(
      "getEndpointBroker",
      "getEndpointBroker(address,bytes32):(address)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );

    return result[0].toAddress();
  }

  try_getEndpointBroker(
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getEndpointBroker",
      "getEndpointBroker(address,bytes32):(address)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  unbond(oracleAddress: Address, endpoint: Bytes, numDots: BigInt): BigInt {
    let result = super.call(
      "unbond",
      "unbond(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );

    return result[0].toBigInt();
  }

  try_unbond(
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "unbond",
      "unbond(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  calcZapForDots(
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): BigInt {
    let result = super.call(
      "calcZapForDots",
      "calcZapForDots(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );

    return result[0].toBigInt();
  }

  try_calcZapForDots(
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "calcZapForDots",
      "calcZapForDots(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBoundDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes
  ): BigInt {
    let result = super.call(
      "getBoundDots",
      "getBoundDots(address,address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );

    return result[0].toBigInt();
  }

  try_getBoundDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBoundDots",
      "getBoundDots(address,address,bytes32):(uint256)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  delegateBond(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): BigInt {
    let result = super.call(
      "delegateBond",
      "delegateBond(address,address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );

    return result[0].toBigInt();
  }

  try_delegateBond(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "delegateBond",
      "delegateBond(address,address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  currentCostOfDot(
    oracleAddress: Address,
    endpoint: Bytes,
    totalBound: BigInt
  ): BigInt {
    let result = super.call(
      "currentCostOfDot",
      "currentCostOfDot(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(totalBound)
      ]
    );

    return result[0].toBigInt();
  }

  try_currentCostOfDot(
    oracleAddress: Address,
    endpoint: Bytes,
    totalBound: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "currentCostOfDot",
      "currentCostOfDot(address,bytes32,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(totalBound)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getIndexSize(holderAddress: Address): BigInt {
    let result = super.call("getIndexSize", "getIndexSize(address):(uint256)", [
      ethereum.Value.fromAddress(holderAddress)
    ]);

    return result[0].toBigInt();
  }

  try_getIndexSize(holderAddress: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getIndexSize",
      "getIndexSize(address):(uint256)",
      [ethereum.Value.fromAddress(holderAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  dispatchAddress(): Address {
    let result = super.call(
      "dispatchAddress",
      "dispatchAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_dispatchAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "dispatchAddress",
      "dispatchAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  returnDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): boolean {
    let result = super.call(
      "returnDots",
      "returnDots(address,address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );

    return result[0].toBoolean();
  }

  try_returnDots(
    holderAddress: Address,
    oracleAddress: Address,
    endpoint: Bytes,
    numDots: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "returnDots",
      "returnDots(address,address,bytes32,uint256):(bool)",
      [
        ethereum.Value.fromAddress(holderAddress),
        ethereum.Value.fromAddress(oracleAddress),
        ethereum.Value.fromFixedBytes(endpoint),
        ethereum.Value.fromUnsignedBigInt(numDots)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class EscrowDotsCall extends ethereum.Call {
  get inputs(): EscrowDotsCall__Inputs {
    return new EscrowDotsCall__Inputs(this);
  }

  get outputs(): EscrowDotsCall__Outputs {
    return new EscrowDotsCall__Outputs(this);
  }
}

export class EscrowDotsCall__Inputs {
  _call: EscrowDotsCall;

  constructor(call: EscrowDotsCall) {
    this._call = call;
  }

  get holderAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get oracleAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class EscrowDotsCall__Outputs {
  _call: EscrowDotsCall;

  constructor(call: EscrowDotsCall) {
    this._call = call;
  }

  get success(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ReleaseDotsCall extends ethereum.Call {
  get inputs(): ReleaseDotsCall__Inputs {
    return new ReleaseDotsCall__Inputs(this);
  }

  get outputs(): ReleaseDotsCall__Outputs {
    return new ReleaseDotsCall__Outputs(this);
  }
}

export class ReleaseDotsCall__Inputs {
  _call: ReleaseDotsCall;

  constructor(call: ReleaseDotsCall) {
    this._call = call;
  }

  get holderAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get oracleAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ReleaseDotsCall__Outputs {
  _call: ReleaseDotsCall;

  constructor(call: ReleaseDotsCall) {
    this._call = call;
  }

  get success(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class UpdateDependenciesCall extends ethereum.Call {
  get inputs(): UpdateDependenciesCall__Inputs {
    return new UpdateDependenciesCall__Inputs(this);
  }

  get outputs(): UpdateDependenciesCall__Outputs {
    return new UpdateDependenciesCall__Outputs(this);
  }
}

export class UpdateDependenciesCall__Inputs {
  _call: UpdateDependenciesCall;

  constructor(call: UpdateDependenciesCall) {
    this._call = call;
  }
}

export class UpdateDependenciesCall__Outputs {
  _call: UpdateDependenciesCall;

  constructor(call: UpdateDependenciesCall) {
    this._call = call;
  }
}

export class BondCall extends ethereum.Call {
  get inputs(): BondCall__Inputs {
    return new BondCall__Inputs(this);
  }

  get outputs(): BondCall__Outputs {
    return new BondCall__Outputs(this);
  }
}

export class BondCall__Inputs {
  _call: BondCall;

  constructor(call: BondCall) {
    this._call = call;
  }

  get oracleAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class BondCall__Outputs {
  _call: BondCall;

  constructor(call: BondCall) {
    this._call = call;
  }

  get bound(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SelfDestructCall extends ethereum.Call {
  get inputs(): SelfDestructCall__Inputs {
    return new SelfDestructCall__Inputs(this);
  }

  get outputs(): SelfDestructCall__Outputs {
    return new SelfDestructCall__Outputs(this);
  }
}

export class SelfDestructCall__Inputs {
  _call: SelfDestructCall;

  constructor(call: SelfDestructCall) {
    this._call = call;
  }
}

export class SelfDestructCall__Outputs {
  _call: SelfDestructCall;

  constructor(call: SelfDestructCall) {
    this._call = call;
  }
}

export class UnbondCall extends ethereum.Call {
  get inputs(): UnbondCall__Inputs {
    return new UnbondCall__Inputs(this);
  }

  get outputs(): UnbondCall__Outputs {
    return new UnbondCall__Outputs(this);
  }
}

export class UnbondCall__Inputs {
  _call: UnbondCall;

  constructor(call: UnbondCall) {
    this._call = call;
  }

  get oracleAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class UnbondCall__Outputs {
  _call: UnbondCall;

  constructor(call: UnbondCall) {
    this._call = call;
  }

  get unbound(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class DelegateBondCall extends ethereum.Call {
  get inputs(): DelegateBondCall__Inputs {
    return new DelegateBondCall__Inputs(this);
  }

  get outputs(): DelegateBondCall__Outputs {
    return new DelegateBondCall__Outputs(this);
  }
}

export class DelegateBondCall__Inputs {
  _call: DelegateBondCall;

  constructor(call: DelegateBondCall) {
    this._call = call;
  }

  get holderAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get oracleAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class DelegateBondCall__Outputs {
  _call: DelegateBondCall;

  constructor(call: DelegateBondCall) {
    this._call = call;
  }

  get boundZap(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class ReturnDotsCall extends ethereum.Call {
  get inputs(): ReturnDotsCall__Inputs {
    return new ReturnDotsCall__Inputs(this);
  }

  get outputs(): ReturnDotsCall__Outputs {
    return new ReturnDotsCall__Outputs(this);
  }
}

export class ReturnDotsCall__Inputs {
  _call: ReturnDotsCall;

  constructor(call: ReturnDotsCall) {
    this._call = call;
  }

  get holderAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get oracleAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get endpoint(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get numDots(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ReturnDotsCall__Outputs {
  _call: ReturnDotsCall;

  constructor(call: ReturnDotsCall) {
    this._call = call;
  }

  get success(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get c(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
